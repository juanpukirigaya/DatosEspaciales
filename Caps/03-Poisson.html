<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.29">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Procesos de Poisson – Introducción al análisis de datos espaciales</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../references.html" rel="next">
<link href="../Caps/02-Exploratorio.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-0815c480559380816a4d1ea211a47e91.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-364982630eef5352dd1537128a8ed5cb.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../Caps/03-Poisson.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Procesos de Poisson</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Buscar" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Introducción al análisis de datos espaciales</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Presentación</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Caps/01-Introduccion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducción</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Caps/02-Exploratorio.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Análisis Exploratorio</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../Caps/03-Poisson.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Procesos de Poisson</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#proceso-poisson-homogéneo" id="toc-proceso-poisson-homogéneo" class="nav-link active" data-scroll-target="#proceso-poisson-homogéneo"><span class="header-section-number">3.1</span> Proceso Poisson homogéneo</a></li>
  <li><a href="#proceso-poisson-espacial-homogéneo" id="toc-proceso-poisson-espacial-homogéneo" class="nav-link" data-scroll-target="#proceso-poisson-espacial-homogéneo"><span class="header-section-number">3.2</span> Proceso Poisson espacial homogéneo</a></li>
  <li><a href="#proceso-poisson-no-homogéneo" id="toc-proceso-poisson-no-homogéneo" class="nav-link" data-scroll-target="#proceso-poisson-no-homogéneo"><span class="header-section-number">3.3</span> Proceso Poisson no homogéneo</a></li>
  <li><a href="#proceso-poisson-espacial-no-homogéneo" id="toc-proceso-poisson-espacial-no-homogéneo" class="nav-link" data-scroll-target="#proceso-poisson-espacial-no-homogéneo"><span class="header-section-number">3.4</span> Proceso Poisson espacial no homogéneo</a></li>
  <li><a href="#pruebas-de-clústering" id="toc-pruebas-de-clústering" class="nav-link" data-scroll-target="#pruebas-de-clústering"><span class="header-section-number">3.5</span> Pruebas de clústering</a>
  <ul class="collapse">
  <li><a href="#prueba-con-quadrat" id="toc-prueba-con-quadrat" class="nav-link" data-scroll-target="#prueba-con-quadrat"><span class="header-section-number">3.5.1</span> Prueba con quadrat</a></li>
  <li><a href="#las-funciones-k-y-l-de-ripley" id="toc-las-funciones-k-y-l-de-ripley" class="nav-link" data-scroll-target="#las-funciones-k-y-l-de-ripley"><span class="header-section-number">3.5.2</span> Las funciones K y L de Ripley</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Procesos de Poisson</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>En este capítulo se presenta uno de los modelos básicos para el tratamiento de datos puntuales: <strong>el proceso Poisson</strong>. Para motivar su uso en problemas espaciales, primero recordaremos la génesis de éste en el contexto de los procesos en el tiempo.</p>
<section id="proceso-poisson-homogéneo" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="proceso-poisson-homogéneo"><span class="header-section-number">3.1</span> Proceso Poisson homogéneo</h2>
<p>Uno de los objetivos principales en el análisis de datos puntuales, es caracterizar conteos de eventos que ocurren de manera (presuntamente) aleatoria. Primero recordemos qué es un proceso de conteo.</p>
<div id="def-conteo" class="theorem definition">
<p><span class="theorem-title"><strong>Definición 3.1 (Proceso de conteo)</strong></span> Sea <span class="math inline">\(N={(N_t)}_{t\geq 0}\)</span> un proceso estocástico. <span class="math inline">\(N\)</span> es un <em>proceso de conteo</em> si toma valores en <span class="math inline">\(\mathbb{N}\cup\{0\}\)</span> y si <span class="math inline">\(s&lt;t\)</span>, entonces, <span class="math inline">\(N_s\leq N_t\)</span>.</p>
</div>
<p>Hay diversas variables aleatorias de conteo, pero la <em>ley de eventos raros de Poisson</em> (ver por ejemplo, <span class="citation" data-cites="Klenke">(<a href="../references.html#ref-Klenke" role="doc-biblioref">Klenke 2020</a>)</span>), sugiere que para el conteo de eventos con probabilidad ‘’baja’’ de ocurrir, es razonable utilizar variables aleatorias Poisson.</p>
<div id="def-pPh" class="theorem definition">
<p><span class="theorem-title"><strong>Definición 3.2 (Proceso Poisson homogéneo)</strong></span> Un proceso de conteo <span class="math inline">\(N={(N_t)}_{t\geq 0}\)</span> es un <em>proceso Poisson homogéneo</em> de intensidad <span class="math inline">\(\lambda&gt;0\)</span> si cumple que</p>
<ol type="1">
<li><span class="math inline">\(N_0=0\)</span>, casi seguramente.</li>
<li>Tiene incrementos independientes y estacionarios, casi seguramente.</li>
<li>Para <span class="math inline">\(s&lt;t\)</span>, un incremento es tal que <span class="math inline">\((N_t-N_s)\sim\text{Poi}(\lambda(t-s))\)</span>.</li>
</ol>
</div>
<p>Existen definiciones del proceso Poisson homogéneo equivalentes a <a href="#def-pPh" class="quarto-xref">Definición&nbsp;<span>3.2</span></a>, pero ésta es de particular utilidad porque nos proporciona una manera de calcular explícitamente las distribuciones finito dimensionales de un proceso Poisson homogéneo y además éstas únicamente dependen de la longitud de los incrementos.</p>
<p>Con estas propiedades, tenemos el siguiente estimador de máxima verosimilitud para el parámetro de intensidad <span class="math inline">\(\lambda\)</span>.</p>
<div id="thm-emvpPh" class="theorem">
<p><span class="theorem-title"><strong>Teorema 3.1 (Distribución conjunta y estimador máximo verosímil)</strong></span> Sea <span class="math inline">\(N={(N_t)}_{t\geq 0}\)</span> un proceso Poisson homogéneo con intensidad <span class="math inline">\(\lambda&gt;0\)</span> observado en el intervalo <span class="math inline">\((0,T_0]\)</span>. Supongamos que se registran <span class="math inline">\(n\)</span> eventos en los tiempos <span class="math inline">\(0&lt;w_1&lt;w_2&lt;\cdots&lt;w_n\leq T_0\)</span>. Entonces</p>
<ul>
<li>Dado que <span class="math inline">\(N_{T_0}=n\)</span>, la densidad conjunta de los tiempos de ocurrencia es</li>
</ul>
<p><span class="math display">\[f_{W_1,\ldots,W_n|N_{T_0}}(w_1,\ldots,w_n|n)=\frac{n!}{T_0^n},\qquad\text{para}\ 0\leq w_1&lt;\cdots&lt;w_n\leq T_0.\]</span></p>
<ul>
<li>La función de verosimilitud para <span class="math inline">\(\lambda\)</span> es</li>
</ul>
<p><span class="math display">\[L(\lambda;\underline{x})=\lambda^ne^{-\lambda T_0}.\]</span></p>
<ul>
<li>Bajo esta formulación, el estimador máximo verosímil de <span class="math inline">\(\lambda\)</span> es</li>
</ul>
<p><span class="math display">\[\widehat{\lambda}=\frac{N_{T_0}}{T_0}.\]</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Prueba</em>. </span></p>
<ul>
<li><p>Esta primera afirmación es un resultado clásico de los procesos de Poisson homogéneos y puede revisarse por ejemplo en <span class="citation" data-cites="Kingman">(<a href="../references.html#ref-Kingman" role="doc-biblioref">Kingman 2007</a>)</span> o en <span class="citation" data-cites="KarlinTaylor2">(<a href="../references.html#ref-KarlinTaylor2" role="doc-biblioref">Karlin y Taylor 1981</a>)</span>.</p></li>
<li><p>Como <span class="math inline">\(N\)</span> es un proceso Poisson homogéneo, la probabilidad de observar exactamente <span class="math inline">\(n\)</span> eventos en el intervalo <span class="math inline">\((0,T_0]\)</span> es</p></li>
</ul>
<p><span class="math display">\[\mathbb{P}[N_{T_0}=n]=e^{-\lambda T_0}\frac{{(\lambda T_0)}^n}{n!}\Bbb{1}_{\mathbb{N}\cup\{0\}}(n).\]</span></p>
<p>Entonces, por el punto anterior, la función de verosimilitud de <span class="math inline">\(\lambda\)</span> es</p>
<p><span class="math display">\[L(\lambda;\underline{x})\propto\mathbb{P}[N_{T_0}=n]f_{W_1,\ldots,W_n|N_{T_0}}(w_1,\ldots,w_n|n)=e^{-\lambda T_0}\frac{{(\lambda T_0)}^n}{n!}\frac{n!}{T_0^n}=\lambda^n e^{-\lambda T_0}.\]</span></p>
<ul>
<li>Tomamos la log-verosimilitud a partir del inciso anterior, de modo que</li>
</ul>
<p><span class="math display">\[\ell(\lambda;\underline{x})=\ln L(\lambda)=n\ln\lambda-\lambda T_0.\]</span></p>
<p>El punto crítico de esta función lo encontramos como</p>
<p><span class="math display">\[\left.\frac{d\ell}{d\lambda}\right|_{\lambda=\lambda^*}=0\iff\frac{n}{\lambda^*}-T_0=0\implies\lambda^*=\frac{n}{T_0}.\]</span></p>
<p>Verificamos que es un máximo con el criterio de la segunda derivada, ya que</p>
<p><span class="math display">\[\left.\frac{d^2\ell}{d\lambda^2}\right|_{\lambda=\lambda^*}=-\frac{n}{\lambda^2}&lt;0.\]</span></p>
<p>De lo anterior, se concluye que el estimador máximo verosímil es</p>
<p><span class="math display">\[\widehat{\lambda}=\frac{N_{T_0}}{T_0}.\]</span></p>
</div>
<p>El valor del estimador es intuitivo ya que dice que <em>la intensidad estimada es el número de eventos por unidad de tiempo</em>, lo cual es consistente con la intuición tras la palabra <em>tasa</em>. Además, se puede verificar que este es un estimador consistente e insesgado que además alcanza la cota de Cramér-Rao.</p>
</section>
<section id="proceso-poisson-espacial-homogéneo" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="proceso-poisson-espacial-homogéneo"><span class="header-section-number">3.2</span> Proceso Poisson espacial homogéneo</h2>
<p>Siguiendo la idea de que un proceso de Poisson sobre el tiempo cuenta cuántos puntos caen en cada intervalo de <span class="math inline">\(\mathbb{R}_+\)</span> tras arrojarlos a una intensidad <span class="math inline">\(\lambda&gt;0\)</span>, es posible extender la noción del proceso Poisson a espacios más generales.</p>
<div id="def-pPhesp" class="theorem definition">
<p><span class="theorem-title"><strong>Definición 3.3 (Proceso Poisson espacial homogéneo)</strong></span> Sea <span class="math inline">\(S\subseteq\mathbb{R}^d\)</span> un conjunto Lebesgue-medible y <span class="math inline">\(\mathcal{A}\)</span> una familia de subconjuntos Lebesgue-medibles de <span class="math inline">\(S\)</span> cerrada bajo uniones e intersecciones finitas. Decimos que un proceso espacial <span class="math inline">\(N={(N(A))}_{A\in\mathcal{A}}\)</span> es un <em>proceso Poisson homogéneo</em> de intensidad <span class="math inline">\(\lambda&gt;0\)</span> en la región <span class="math inline">\(S\)</span> si - Para todo <span class="math inline">\(A\in\mathcal{A}\)</span> se tiene que <span class="math inline">\(N(A)\sim\text{Poi}(\lambda|A|)\)</span>, donde <span class="math inline">\(|A|\)</span> representa la medida de Lebesgue del conjunto <span class="math inline">\(A\)</span>. - Para todos <span class="math inline">\(A_1,\ldots,A_n\in\mathcal{A}\)</span> disjuntos, las variables aleatorias <span class="math inline">\(N(A_1),\ldots,N(A_n)\)</span> son independientes. - Dado que <span class="math inline">\(N(A)=n\)</span>, las ubicaciones <span class="math inline">\(X_1,\ldots,X_n\)</span> de los eventos son uniformes en <span class="math inline">\(A\)</span>, es decir</p>
<p><span class="math display">\[f_{X_1,\ldots,X_n|N(A)}(x_1,\ldots,x_n|n)=\frac{1}{{|A|}^n}.\]</span></p>
</div>
<p>Así, un proceso Poisson espacial homogéneo es un proceso donde la intensidad con la que se arrojan puntos a una región <span class="math inline">\(A\)</span> del espacio, es proporcional al tamaño de éste. Esto hace sentido con la idea intuitiva de que ‘’es más probable que contemos más puntos si el área es más grande’’.</p>
<p>En analogía, metodológica e intuitivamente, al caso temporal, tenemos el siguiente estimador para la intensidad de un proceso Poisson espacial homogéneo.</p>
<div id="thm-emvpPhe" class="theorem">
<p><span class="theorem-title"><strong>Teorema 3.2 (Estimador máximo verosímil)</strong></span> Sea <span class="math inline">\(N={(N(A))}_{A\in\mathcal{A}}\)</span> un proceso Poisson espacial homogéneo con intensidad <span class="math inline">\(\lambda&gt;0\)</span> observado en la región <span class="math inline">\(A_0\)</span>, de tamaño <span class="math inline">\(|A_0|\)</span>. Supongamos que se registran <span class="math inline">\(n\)</span> eventos en las posiciones <span class="math inline">\(x_1,x_2,\ldots,x_n\in A_0\)</span>. Entonces el estimador máximo verosímil de <span class="math inline">\(\lambda\)</span> es</p>
<p><span class="math display">\[\widehat{\lambda}=\frac{N(A_0)}{|A_0|}.\]</span></p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Prueba</em>. </span>Siguiendo la idea del caso temporal, la función de verosimilitud de <span class="math inline">\(\lambda\)</span> se puede calcular con las distribuciones conocidas como</p>
<p><span class="math display">\[
\begin{align*}
L(\lambda;\underline{x})&amp;\propto f_{X_1,\ldots,X_n|N(A_0)}(x_1,\ldots,x_n)\mathbb{P}[N(A_0)=n]\\
&amp;=e^{-\lambda|A_0|}\frac{{(\lambda|A_0|)}^n}{n!}\frac{1}{{|A_0|}^n}=\frac{\lambda^n}{n!}e^{-\lambda|A|}.
\end{align*}
\]</span></p>
<p>La log-verosimilitud es</p>
<p><span class="math display">\[\ell(\lambda;\underline{x})=n\ln\lambda-\lambda|A_0|\]</span></p>
<p>El punto crítico de esta función lo encontramos como</p>
<p><span class="math display">\[\left.\frac{d\ell}{d\lambda}\right|_{\lambda=\lambda^*}=0\iff\frac{n}{\lambda^*}-|A_0|=0\implies\lambda^*=\frac{n}{|A_0|}.\]</span></p>
<p>Verificamos que es un máximo con el criterio de la segunda derivada, ya que</p>
<p><span class="math display">\[\left.\frac{d^2\ell}{d\lambda^2}\right|_{\lambda=\lambda^*}=-\frac{n}{\lambda^2}&lt;0.\]</span></p>
<p>De lo anterior, se concluye que el estimador máximo verosímil es</p>
<p><span class="math display">\[\widehat{\lambda}=\frac{N(A_0)}{|A_0|}.\]</span></p>
</div>
<p>El valor del estimador es intuitivo ya que dice que <em>la intensidad estimada es el número de eventos por unidad de volumen</em>, lo cual es consistente con la intuición tras la palabra <em>tasa</em>. Además, se puede verificar que este es un estimador consistente e insesgado que además alcanza la cota de Cramér-Rao.</p>
</section>
<section id="proceso-poisson-no-homogéneo" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="proceso-poisson-no-homogéneo"><span class="header-section-number">3.3</span> Proceso Poisson no homogéneo</h2>
<p>Regresamos al contexto temporal para motivar el siguiente modelo. Una de las principales debilidades del proceso Poisson homogéneo viene de la <em>homogeneidad</em>. El asumir que la intensidad es constante puede llevar a ideas como que los accidentes de tránsito ocurren a la misma tasa en la madrugada que en la tarde, y eso no es una hipótesis razonable, en general. La manera más inmediata de resolver esto es considerando que la intensidad ahora también varía en el tiempo.</p>
<div id="def-pPnh" class="theorem definition">
<p><span class="theorem-title"><strong>Definición 3.4 (Proceso Poisson no homogéneo)</strong></span> Sea <span class="math inline">\(\lambda:[0,\infty)\to[0,\infty)\)</span> una función tal que</p>
<p><span class="math display">\[\int_0^\infty\lambda(t)dt=\infty.\]</span></p>
<p>Un proceso de contar <span class="math inline">\(N={(N_t)}_{t\geq 0}\)</span> es un <em>proceso Poisson no homogéneo</em> con función de intensidad <span class="math inline">\(\lambda(t)\)</span> si satisface que</p>
<ol type="1">
<li><span class="math inline">\(N_0=0\)</span> casi seguramente.</li>
<li>Tiene incrementos independientes.</li>
<li><span class="math inline">\(\mathbb{P}[N_{t+h}-N_t=1]=\lambda(t)h+o(h)\)</span>.</li>
<li><span class="math inline">\(\mathbb{P}[N_{t+h}-N_t\geq 2]=o(h)\)</span>.</li>
</ol>
</div>
<p>Como consecuencia de esta formulación infinitesimal, se tiene el siguiente resultado, el cual da la función de densidad de los incrementos de un proceso Poisson no homogéneo.</p>
<div id="thm-denspPnh" class="theorem">
<p><span class="theorem-title"><strong>Teorema 3.3 (Densidad de los incrementos)</strong></span> Sea <span class="math inline">\(N={(N_t)}_{t\geq 0}\)</span> un proceso Poisson no homogéneo con función de intensidad <span class="math inline">\(\lambda\)</span>. Entonces, para cada <span class="math inline">\(n\geq 0\)</span> y <span class="math inline">\(0\leq s&lt;t\)</span>, se tiene que</p>
<p><span class="math display">\[\mathbb{P}[N_{t+s}-N_t=n]=\exp\left[-(\Lambda(t+s)-\Lambda(t))\right]\frac{{(\Lambda(t+s)-\Lambda(t))}^n}{n!},\]</span></p>
<p>donde</p>
<p><span class="math display">\[\Lambda(t)=\int_0^t\lambda(u)du\]</span></p>
<p>es la intensidad acumulada. Más aún, dado que han ocurrido <span class="math inline">\(n\)</span> eventos en el intervalo <span class="math inline">\((0,T]\)</span>, los tiempos de ocurrencia de éstos son tales que</p>
<p><span class="math display">\[f_{W_1,\ldots,W_n|N_t}(w_1,\ldots,t_n|n)\propto\frac{1}{\Lambda(t)}\prod_{i=1}^n\lambda(w_i).\]</span></p>
</div>
<p>Es importante notar que ahora se busca estimar <em>una función</em>. La función de verosimilitud de este problema es</p>
<p><span class="math display">\[L(\lambda(t))=\left[\prod_{i=1}^n\lambda(t_i)\right]\exp\left(-\Lambda(T)\right).\]</span></p>
<p>Los métodos utilizados para estos problemas, son métodos para estimación de funciones. Hay distintas maneras de abordar este problema. El problema es que, como la función <span class="math inline">\(\lambda\)</span> no es propiamente una densidad, es necesario trabajar con alguna función relacionada que sí lo sea. Si consideramos la función <span class="math inline">\(f:[0,T]\to\mathbb{R}\)</span> dada por</p>
<p><span class="math display">\[f(t)=\frac{\lambda(t)}{\Lambda(T)},\]</span></p>
<p>ahora sí tenemos una función de densidad en el intervalo <span class="math inline">\([0,T]\)</span>. Hay muchas maneras de resolver este problema de estimación de funciones. La manera más directa y como secuencia natural al <a href="http://personal.cimat.mx:8181/~leticia.ramirez/Modelos_Estadisticos_I/Cap5.html#estructura-de-los-modelos-lineales-generalizados">Curso de Modelos Estadísticos</a>, más específicamente al tema de <em>regresión Poisson</em>. Entonces, utilizando una función de enlace <span class="math inline">\(\log\)</span>, se tiene el <em>modelo Log-Lineal</em></p>
<p><span class="math display">\[\log\lambda(t)=\beta_0+\beta_1Z_1(t)+\cdots+\beta_pZ_p(t),\]</span></p>
<p>donde <span class="math inline">\(Z_1,\ldots,Z_p\)</span> son covariables temporales y <span class="math inline">\(\beta_0,\ldots,\beta_p\)</span> son los coeficientes a estimar (podría verse como un problema de estimación de tendencia y estacionalidad de una serie de tiempo, por ejemplo). Otra manera sería considerar la versión empírica de <span class="math inline">\(\lambda\)</span> que se tiene por los tiempos <span class="math inline">\(t_1,\ldots,t_n\)</span> y utilizar algún método de suavizamiento por kernel de modo que se tendría</p>
<p><span class="math display">\[\widehat{\lambda}(t)=\sum_{i=1}^n\frac{1}{h}\kappa\left(\frac{t-t_i}{h}\right),\]</span></p>
<p>para <span class="math inline">\(\kappa\)</span> un kernel Gaussiano y un ancho de banda <span class="math inline">\(h\)</span>.</p>
<p>Una manera de validar modelos de procesos Poisson no homogéneos y también de simularlos es el siguiente, que relaciona un proceso Poisson homogéneo con uno no homogéneo a partir de un cambio de tiempo determinista.</p>
<div id="thm-pPhtopPnh" class="theorem">
<p><span class="theorem-title"><strong>Teorema 3.4 (Relación entre procesos Poisson homogéneos y no homogéneos)</strong></span> &nbsp;</p>
<ul>
<li>Sea <span class="math inline">\({(N_t)}_{t\geq 0}\)</span> un proceso Poisson no homogéneo con funciones de intensidad <span class="math inline">\(\lambda\)</span> y de intensidad acumulada <span class="math inline">\(\Lambda\)</span>, con inversa generalizada <span class="math inline">\(\Lambda^{-1}\)</span>. Entonces el proceso <span class="math inline">\({(N_{\Lambda^{-1}(t)})}_{t\geq 0}\)</span> es un proceso Poisson homogéneo de intensidad <span class="math inline">\(\lambda=1\)</span>.</li>
<li>Sea <span class="math inline">\({(N_t)}_{t\geq 0}\)</span> un proceso Poisson homogéneo de intensidad <span class="math inline">\(\lambda=1\)</span> y sea <span class="math inline">\(\lambda:[0,\infty)\to[0,\infty)\)</span> una función no negativa tal que <span class="math inline">\(\displaystyle\int_0^\infty\lambda(t)dt=\infty\)</span>. Definimos la función <span class="math inline">\(\Lambda\)</span> como <span class="math inline">\(\displaystyle\Lambda(t)=\int_0^t\lambda(u)du\)</span>. Entonces el proceso <span class="math inline">\({(N_{\Lambda(t)})}_{t\geq 0}\)</span> es un proceso Poisson no homogéneo con función de intensidad <span class="math inline">\(\lambda\)</span>.</li>
</ul>
</div>
</section>
<section id="proceso-poisson-espacial-no-homogéneo" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="proceso-poisson-espacial-no-homogéneo"><span class="header-section-number">3.4</span> Proceso Poisson espacial no homogéneo</h2>
<p>Con las ideas de la sección anterior, un proceso Poisson espacial no homogéneo, intuitivamente, es uno en que la intensidad depende del punto del espacio en el que uno se encuentre. Teóricamente, la extensión no es tan directa como se pensaría en primera instancia.</p>
<div id="def-pPenh" class="theorem definition">
<p><span class="theorem-title"><strong>Definición 3.5 (Proceso Poisson espacial no homogéneo)</strong></span> Sea <span class="math inline">\(S\subseteq\mathbb{R}^d\)</span> un conjunto Lebesgue-medible y <span class="math inline">\(\mathcal{A}\)</span> una familia de subconjuntos Lebesgue-medibles de <span class="math inline">\(S\)</span> cerrada bajo uniones e intersecciones finitas. Decimos que un proceso espacial <span class="math inline">\(N={(N(A))}_{A\in\mathcal{A}}\)</span> es un <em>proceso Poisson no homogéneo</em> con función de intensidad <span class="math inline">\(\lambda:S\to[0,\infty)\)</span> en la región <span class="math inline">\(S\)</span> si</p>
<ul>
<li>Para todo <span class="math inline">\(A\in\mathcal{A}\)</span> se tiene que <span class="math inline">\(N(A)\sim\text{Poi}(\Lambda(A))\)</span>, donde</li>
</ul>
<p><span class="math display">\[\Lambda(A)=\int_A\lambda(x)dx.\]</span></p>
<ul>
<li>Para todos <span class="math inline">\(A_1,\ldots,A_n\in\mathcal{A}\)</span> disjuntos, las variables aleatorias <span class="math inline">\(N(A_1),\ldots,N(A_n)\)</span> son independientes.</li>
<li>Dado que <span class="math inline">\(N(A)=n\)</span>, las ubicaciones <span class="math inline">\(X_1,\ldots,X_n\)</span> de los eventos son tales que</li>
</ul>
<p><span class="math display">\[ f_{X_1,\ldots,X_n|N(A)}(x_1,\ldots,x_n|n)=\frac{1}{\Lambda(A)}\prod_{i=1}^n\lambda(x_i). \]</span></p>
</div>
<p>En este caso, la función de intensidad en realidad se toma como densidad para una medida, a la cual se le llama también <em>medida de Poisson</em>. Detalles teóricos sobre estos procesos de Poisson con intensidades <span class="math inline">\(\lambda\)</span> generales se pueden revisar en <span class="citation" data-cites="Kingman">(<a href="../references.html#ref-Kingman" role="doc-biblioref">Kingman 2007</a>)</span>.</p>
<div id="exm-medarea" class="theorem example">
<p><span class="theorem-title"><strong>Ejemplo 3.1</strong></span> Sean <span class="math inline">\(S\subseteq\mathbb{R}^2\)</span> y <span class="math inline">\(\lambda(x,y)=e^{-(x^2+y^2)}\)</span>. Entonces, si <span class="math inline">\(A=\{(x,y)\ :\ x^2+y^2\leq r^2\}\)</span>, la medida de <span class="math inline">\(A\)</span> respecto a <span class="math inline">\(\lambda\)</span> es</p>
<p><span class="math display">\[\Lambda(A)=\int_A e^{-(x^2+y^2)}dxdy=\pi(1-e^{-r^2}).\]</span></p>
</div>
<p>La manera en la que se puede hacer inferencia sobre la función <span class="math inline">\(\lambda\)</span> es la misma que en el caso temporal. La función de verosimilitud sobre la región <span class="math inline">\(A\)</span> de este modelo es</p>
<p><span class="math display">\[L(\lambda(t))=\left[\prod_{i=1}^n\lambda(x_i)\right]\exp(-\Lambda(A)).\]</span></p>
<p>El modelo Log-Lineal en este caso es</p>
<p><span class="math display">\[\log\lambda(s)=\beta_0(s)+\beta_1Z(s).\]</span></p>
<p>Una hipótesis usual es considerar que <span class="math inline">\(Z={(Z(s))}_{s\in A}\)</span> es un campo Gaussiano de media 0. Dos métodos clásicos para la estimación son los siguientes:</p>
<ul>
<li>Con una discretización del espacio en una rejilla de <span class="math inline">\(n_1\times n_2=N\)</span> celdas <span class="math inline">\({(s_{ij})}_{(i,j)\in\{1,\ldots,n_1\}\times\{1,\ldots,n_2\}}\)</span>. El número promedio de eventos por celda es</li>
</ul>
<p><span class="math display">\[\Lambda_{ij}=\int_{s_{ij}}\exp(\eta(s))ds\approx|s_{ij}|\exp(\eta_{ij}).\]</span></p>
<p>Entonces, dado un campo latente <span class="math inline">\(\eta_{ij}\)</span>, el número de observaciones en la rejilla es tal que</p>
<p><span class="math display">\[(y_{ij}|\eta_{ij})\sim\text{Poi}(|s_{ij}|\exp(\eta_{ij})),\]</span></p>
<p>El campo latente puede estimarse a partir de otras covariables y efectos aleatorios como</p>
<p><span class="math display">\[\eta_{ij}=c(s_{ij})\beta+f_s(s_{ij})+f_u(s_{ij}),\]</span></p>
<p>donde <span class="math inline">\(\beta=(\beta_0,\beta_1,\ldots,\beta_p),\ c(s_{ij})=(1,c_1(s_{ij}),\ldots,c_p(s_{ij})),\ f_s\)</span> es un ruido dependiente de la estructura espacial y <span class="math inline">\(f_u\)</span> es un ruido no necesariamente dependiente del espacio.</p>
<ul>
<li>Con un proceso análogo al autorregresivo de las series de tiempo</li>
</ul>
<p><span class="math display">\[Z(s)=\sum_{i=1}^nZ_i\phi_i(s),\]</span></p>
<p>donde <span class="math inline">\((Z_1,\ldots,Z_n)\)</span> es un vector Gaussiano y <span class="math inline">\({(\phi_i(s))}_{i=1}^n\)</span> es una base de funciones deterministas. Una alternativa usual es considerar que el campo Gaussiano tiene matriz de covarianza como en el variograma de Mathéron presentado en la sección <a href="02-Exploratorio.html#sec-variograma" class="quarto-xref"><span>Sección 2.2.2</span></a>.</p>
<p>Este modelo no se limita únicamente a que tome valores de puntos en el espacio. La definición contempla casos en los que la función de intensidad sea de la forma <span class="math inline">\(\lambda:[0,\infty)\times\mathbb{R}^d\to\mathbb{R}_+\)</span> como <span class="math inline">\(\lambda=\lambda(t,x)\)</span>, es decir, que la intensidad dependa del instante y de la ubicación. Un problema para ilustrar esta forma de <span class="math inline">\(\lambda\)</span> es el de las lluvias, que su intensidad puede depender de la hora del día y del lugar del mundo del que se trate.</p>
<p>De la misma manera que con el análisis de procesos temporales, es posible usar suavizamiento por kernel para estimar <span class="math inline">\(\lambda\)</span> a partir de una medida empírica. Como se mencionó en el caso temporal, la función <span class="math inline">\(\lambda\)</span> no necesariamente es una densidad, pero la función</p>
<p><span class="math display">\[f(x)=\frac{1}{\Lambda(A)}\lambda(x)\]</span></p>
<p>sí es una densidad en la región <span class="math inline">\(A\)</span>. Entonces, los estimadores de kernel para <span class="math inline">\(f\)</span> y <span class="math inline">\(\lambda\)</span> basados en un conjunto de observaciones <span class="math inline">\(X_1,\ldots,X_n\)</span> están dados por</p>
<p><span class="math display">\[
\begin{align*}
\widehat{f}(x)&amp;=\frac{1}{n}\sum_{i=1}^n\frac{1}{h^2}\kappa\left(\frac{x-x_i}{h}\right),\\
\widehat{\lambda}(x)&amp;=\sum_{i=1}^n\frac{1}{h^2}\kappa\left(\frac{x-x_i}{h}\right),
\end{align*}
\]</span></p>
<p>donde <span class="math inline">\(h\)</span> es un ancho de banda. Una elección usual para <span class="math inline">\(\kappa\)</span> es la normal multivariada.</p>
</section>
<section id="pruebas-de-clústering" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="pruebas-de-clústering"><span class="header-section-number">3.5</span> Pruebas de clústering</h2>
<p>La última propiedad enunciada en la definición <a href="#def-pPhesp" class="quarto-xref">Definición&nbsp;<span>3.3</span></a> hace que al proceso Poisson espacial homogéneo también se le llame el modelo de <em>aleatoriedad espacial completa</em> o <em>CSR</em> por sus siglas en inglés (<strong>c</strong>omplete <strong>s</strong>patial <strong>r</strong>andomness). Si bien la mayoría de procesos están lejos de ser CSR, éste ayuda a diferenciar entre patrones regulares y conglomerados (o clusterizados).</p>
<p>Dada una muestra de puntos, un buen primer paso es preguntarse si hay evidencia para rechazar la hipótesis de que se trate de un CSR.</p>
<section id="prueba-con-quadrat" class="level3" data-number="3.5.1">
<h3 data-number="3.5.1" class="anchored" data-anchor-id="prueba-con-quadrat"><span class="header-section-number">3.5.1</span> Prueba con quadrat</h3>
<p>Un método para dar evidencia a favor o en contra de la hipótesis nula <span class="math inline">\(H_0\)</span> ser CSR es con una prueba <span class="math inline">\(\chi^2\)</span> (ver <span class="citation" data-cites="Moraga">(<a href="../references.html#ref-Moraga" role="doc-biblioref">Moraga 2023</a>)</span>). El <em>método quadrat</em> coincide en particionar la región de estudio en <span class="math inline">\(r\)</span> renglones y <span class="math inline">\(c\)</span> columnas, de modo que se obtenga una retícula de regiones disjuntas de la misma área (quadrats). Así, bajo <span class="math inline">\(H_0\)</span>, el número esperado de observaciones en cualquier región de la retícula es el mismo: sean <span class="math inline">\(n\)</span> el número de observaciones, <span class="math inline">\(m\)</span> el número de quadrats y <span class="math inline">\(n_i\)</span> el número de puntos en el <span class="math inline">\(i\)</span>-ésimo quadrat; entonces el número esperado de puntos en cada quadrat es <span class="math inline">\(n^*=n/m\)</span>.</p>
<p>Dado lo anterior, el estadístico de prueba se puede calcular por</p>
<p><span class="math display">\[X^2=\sum_{i=1}^m\frac{{(n_i-n^*)}^2}{n^*}.\]</span></p>
<p>Se puede verificar que, bajo <span class="math inline">\(H_0\)</span>, entonces <span class="math inline">\(X^2\sim\chi^2_{m-1}\)</span>.</p>
<p>Es muy importante destacar que este método depende de la configuración de quadrats (puede haber regiones sin puntos). También esta prueba no puede distinguir entre distintos patrones localmente.</p>
<p>En <strong>R</strong> se tiene la función <strong>quadrat.test()</strong> para probar la hipótesis de CSR. La interpretación es de acuerdo a la siguiente clave:</p>
<ul>
<li><strong>alternative = “two.sided”</strong> prueba <span class="math inline">\(H_0:\)</span> CSR vs.&nbsp;<span class="math inline">\(H_a:\)</span> no CSR (regular o clusterizada).</li>
<li><strong>alternative = “regular”</strong> prueba <span class="math inline">\(H_0:\)</span> CSR o clusterizada vs.&nbsp;<span class="math inline">\(H_a:\)</span> regular.</li>
<li><strong>alternative = “clustered”</strong> prueba <span class="math inline">\(H_0:\)</span> CSR o regular vs.&nbsp;<span class="math inline">\(H_a:\)</span> clusterizada.</li>
</ul>
</section>
<section id="las-funciones-k-y-l-de-ripley" class="level3" data-number="3.5.2">
<h3 data-number="3.5.2" class="anchored" data-anchor-id="las-funciones-k-y-l-de-ripley"><span class="header-section-number">3.5.2</span> Las funciones K y L de Ripley</h3>
<p>Pensando en datos puntuales sobre regiones del espacio <span class="math inline">\(S\subseteq\mathbb{R}^2\)</span>, se puede usar otro estadístico para probar la homogeneidad del proceso puntual.</p>
<div id="def-KRipley" class="theorem definition">
<p><span class="theorem-title"><strong>Definición 3.6 (Funciones K y L de Ripley)</strong></span> Sea <span class="math inline">\(N={(N(A))}_{A\in\mathcal{A}}\)</span> un proceso Poisson espacial en <span class="math inline">\(\mathbb{R}^2\)</span> con función de intensidad <span class="math inline">\(\lambda\)</span>.</p>
<ul>
<li>La función <em>K de Ripley</em> es la función dada por</li>
</ul>
<p><span class="math display">\[K(s)=\frac{1}{\lambda}\mathbb{E}_0[N(B_r(0)\backslash\{0\})],\]</span></p>
<p>donde <span class="math inline">\(\mathbb{E}_0\)</span> es la esperanza condicionada a que haya un punto en el origen y <span class="math inline">\(B_r(0)\)</span> es la bola de radio <span class="math inline">\(r\)</span> centrada en el origen.</p>
<ul>
<li>La función <em>L de Ripley</em> es la función dada por</li>
</ul>
<p><span class="math display">\[L(r)=\sqrt{\frac{K(r)}{\pi}}.\]</span></p>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Ims/kemp.jpg" class="img-fluid figure-img"></p>
<figcaption>Visualización del cálculo de la función de Ripley empírica.</figcaption>
</figure>
</div>
<p>Notemos que bajo la hipótesis de CSR, la función <span class="math inline">\(\lambda\)</span> es constante y las funciones de Ripley están dadas explícitamente por</p>
<p><span class="math display">\[
\begin{align*}
K(r)&amp;=\frac{1}{\lambda}\mathbb{E}_0[N(B_r(0)\backslash\{0\})]=\frac{1}{\lambda}\mathbb{E}_0[N(B_r(0))]\\
&amp;=\frac{|B_r(0)|\lambda}{\lambda}=\pi r^2,\\
L(r)&amp;=\sqrt{\frac{K(r)}{\pi}}=\sqrt{\frac{\pi r^2}{\pi}}=r.
\end{align*}
\]</span></p>
<p>Dada la forma de la función <span class="math inline">\(K\)</span> bajo CSR, se tiene el siguiente criterio:</p>
<ul>
<li>Si <span class="math inline">\(K(r)&gt;\pi r^2\)</span> o, equivalentemente, <span class="math inline">\(L(r)&gt;r\)</span>, la función de intensidad favorece el clústering.</li>
<li>Si <span class="math inline">\(K(r)&lt;\pi r^2\)</span> o, equivalentemente, <span class="math inline">\(L(r)&lt;r\)</span>, la función de intensidad favorece la dispersión.</li>
</ul>
<p>Una manera de estimar la función <span class="math inline">\(K\)</span> es utilizando que es un conteo. Para hacer éste, es necesario tomar en cuenta que los eventos contados cerca de la frontera de una región <span class="math inline">\(A\)</span> pueden ser bajos. Por ello s eintroduce un peso <span class="math inline">\(w_{ij}\)</span> correspondiente al recíproco a la proporción del círculo con centro en <span class="math inline">\(x_i\)</span> y radio <span class="math inline">\(d_{ij}\)</span> contenido en <span class="math inline">\(A\)</span>.</p>
<div id="def-KLRipleyestiadas" class="theorem definition">
<p><span class="theorem-title"><strong>Definición 3.7 (Estimadores de las funciones de Ripley)</strong></span> Sea <span class="math inline">\(X=\{X_1,\ldots,X_n\}\)</span> un patrón de puntos en <span class="math inline">\(S\)</span>. La <em>función <span class="math inline">\(K\)</span> de Ripley empírica</em> está dada por</p>
<p><span class="math display">\[\widehat{K}(r)=\frac{1}{\widehat{\lambda}n}\sum_{i=1}^n\sum_{j\neq i}w_{ij}^{-1}\Bbb{1}_{\{d_{ij}\leq r\}}.\]</span></p>
<p>Bajo la hipótesis de CSR, el estimador de <span class="math inline">\(\lambda\)</span> es <span class="math inline">\(\displaystyle\widehat{\lambda}=\frac{n-1}{|S|}\)</span>, entonces la función <span class="math inline">\(K\)</span> empírica es</p>
<p><span class="math display">\[\widehat{K}(r)=\frac{|S|}{n(n-1)}\sum_{i=1}^n\sum_{j\neq i}w_{ij}^{-1}\Bbb{1}_{\{d_{ij}\leq r\}}.\]</span></p>
<p>Del mismo modo, la <em>la función <span class="math inline">\(L\)</span> de Ripley empírica</em> está dada por</p>
<p><span class="math display">\[\widehat{L}(r)=\sqrt{\frac{\widehat{K}(r)}{\pi}}.\]</span></p>
</div>
<p>Los intervalos de confianza para estas funciones empíricas típicamente son intervalos bootstrap. La idea de utilizar las funciones de Ripley es parecida a la de las gráficas QQ en inferencia de distribuciones: <em>entre más cerca esté el proceso de ser homogéneo en el espacio, más parecidas serán las funciones teórica y empírica</em>.</p>
<p>En el siguiente ejemplo se muestra un ejemplo del uso de estas funciones con datos simulados directamente de un proceso Poisson homogéneo.</p>
<div id="exm-KLartificial" class="theorem example">
<p><span class="theorem-title"><strong>Ejemplo 3.2</strong></span> Primero generamos un proceso Poisson homogéneo de intensidad <span class="math inline">\(\lambda=100\)</span> y revisamos la región <span class="math inline">\(A=[0,1]\times[0,1]\)</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spatstat)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">612000</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">rpoispp</span>(<span class="at">lambda =</span> <span class="dv">100</span>, <span class="at">win =</span> <span class="fu">owin</span>(<span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(X, </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>     <span class="at">main =</span> <span class="st">"Proceso de Poisson Homogéneo"</span>,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>     <span class="at">pch =</span> <span class="dv">20</span>,                      </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>     <span class="at">cols =</span> <span class="st">"blue"</span>,                  </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>     <span class="at">show.window =</span> <span class="cn">TRUE</span>,             </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>     <span class="at">axes =</span> <span class="cn">TRUE</span>,                    </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab =</span> <span class="st">"X"</span>,          </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab =</span> <span class="st">"Y"</span>        </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>     )</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-Poisson_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>A partir de la simulación, calculamos el estimador de <span class="math inline">\(\lambda\)</span> bajo el supuesto de CSR.</p>
<div class="cell">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>lambda_hat<span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="st">"lambda_hat="</span>,<span class="fu">intensity</span>(X)) </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>lambda_hat</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>  X.lambda_hat.. intensity.X.
1    lambda_hat=           94</code></pre>
</div>
</div>
<p>Este estimador sí es bastante parecido al valor real utilizado. Así, la función <span class="math inline">\(K\)</span> empírica superpuesta a la teórica se ve como</p>
<div class="cell">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>K <span class="ot">&lt;-</span> <span class="fu">Kest</span>(X, <span class="at">correction =</span> <span class="st">"border"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>K_env <span class="ot">&lt;-</span> <span class="fu">envelope</span>(X, Kest, <span class="at">nsim=</span><span class="dv">99</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 99 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 
99.

Done.</code></pre>
</div>
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(K_env, <span class="at">main =</span> <span class="st">"Función K con bandas de confianza de 99 simulaciones"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-Poisson_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>O, más claramente con la función <span class="math inline">\(L\)</span>, se ve como</p>
<div class="cell">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>L<span class="ot">&lt;-</span><span class="fu">Lest</span>(X, <span class="at">correction =</span> <span class="st">"border"</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>L_env <span class="ot">&lt;-</span> <span class="fu">envelope</span>(X, Lest, <span class="at">nsim=</span><span class="dv">99</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 99 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 
99.

Done.</code></pre>
</div>
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(L_env, <span class="at">main =</span> <span class="st">"Función L con bandas de confianza de 99 simulaciones"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-Poisson_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Al ser las funciones empíricas parecidas a las funciones teóricas, podemos afirmar que los datos trabajados sí corresponden a un CSR.</p>
<p>Para sustentar esta última afirmación, podemos utilizar la prueba quadrat, la cual también da evidencia a favor de la hipótesis de CSR.</p>
<div class="cell">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">quadrat.test</span>(X, <span class="at">nx =</span> <span class="dv">4</span>, <span class="at">ny =</span> <span class="dv">4</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
    Chi-squared test of CSR using quadrat counts

data:  X
X2 = 10.17, df = 15, p-value = 0.3822
alternative hypothesis: two.sided

Quadrats: 4 by 4 grid of tiles</code></pre>
</div>
</div>
</div>
<p>Para ejemplificar cuándo no ocurre el CSR, tenemos otro ejemplo artificial donde la intensidad es muy alta cerca del <span class="math inline">\((0,0)\)</span>.</p>
<div id="exm-KLartificialnh" class="theorem example">
<p><span class="theorem-title"><strong>Ejemplo 3.3</strong></span> Primero generamos un proceso Poisson no homogéneo de intensidad <span class="math inline">\(\displaystyle\lambda(x,y)=100{(x^2+y^2)}^{-1/2}\Bbb{1}_{\{x^2+y^2&gt;0\}}\)</span> y revisamos la región <span class="math inline">\(A=[0,1]\times[0,1]\)</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spatstat)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>lambda <span class="ot">&lt;-</span> <span class="cf">function</span>(x, y) { <span class="fu">ifelse</span>(x <span class="sc">==</span> <span class="dv">0</span> <span class="sc">&amp;</span> y <span class="sc">==</span> <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">100</span> <span class="sc">/</span> <span class="fu">sqrt</span>(x<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> y<span class="sc">^</span><span class="dv">2</span>)) }</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.01</span>, <span class="dv">1</span>, <span class="at">length.out =</span> <span class="dv">100</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.01</span>, <span class="dv">1</span>, <span class="at">length.out =</span> <span class="dv">100</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="at">x =</span> x, <span class="at">y =</span> y)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>grid<span class="sc">$</span>lambda <span class="ot">&lt;-</span> <span class="fu">lambda</span>(grid<span class="sc">$</span>x, grid<span class="sc">$</span>y)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>lambda_im <span class="ot">&lt;-</span> <span class="fu">as.im</span>(<span class="fu">data.frame</span>(<span class="at">x =</span> grid<span class="sc">$</span>x, <span class="at">y =</span> grid<span class="sc">$</span>y, <span class="at">z =</span> grid<span class="sc">$</span>lambda), </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>                   <span class="at">W =</span> <span class="fu">owin</span>(<span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)))</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">612003</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>X_nhpp <span class="ot">&lt;-</span> <span class="fu">rpoispp</span>(lambda_im)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(X_nhpp, </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>     <span class="at">main =</span> <span class="st">"Proceso de Poisson no Homogéneo"</span>,</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>     <span class="at">pch =</span> <span class="dv">20</span>,                      </span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>     <span class="at">cols =</span> <span class="st">"blue"</span>,                  </span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>     <span class="at">show.window =</span> <span class="cn">TRUE</span>,             </span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>     <span class="at">axes =</span> <span class="cn">TRUE</span>,                    </span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab =</span> <span class="st">"X"</span>,          </span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab =</span> <span class="st">"Y"</span>        </span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>     )</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-Poisson_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Así, la función <span class="math inline">\(K\)</span> empírica superpuesta a la teórica se ve como</p>
<div class="cell">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>K_empirica <span class="ot">&lt;-</span> <span class="fu">Kest</span>(X_nhpp, <span class="at">correction =</span> <span class="st">"border"</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>K_empenv <span class="ot">&lt;-</span> <span class="fu">envelope</span>(X_nhpp, Kest, <span class="at">nsim=</span><span class="dv">99</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 99 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 
99.

Done.</code></pre>
</div>
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(K_empenv, <span class="at">main =</span> <span class="st">"Función K con bandas de confianza de 99 simulaciones"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-Poisson_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>O, más claramente con la función <span class="math inline">\(L\)</span>, se ve como</p>
<div class="cell">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>L_empirica <span class="ot">&lt;-</span> <span class="fu">Lest</span>(X_nhpp, <span class="at">correction =</span> <span class="st">"border"</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>L_empenv <span class="ot">&lt;-</span> <span class="fu">envelope</span>(X_nhpp, Lest, <span class="at">nsim=</span><span class="dv">99</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Generating 99 simulations of CSR  ...
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 
99.

Done.</code></pre>
</div>
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(L_empenv, <span class="at">main =</span> <span class="st">"Función L con bandas de confianza de 99 simulaciones"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03-Poisson_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Al ser las funciones empíricas muy distintas a las funciones teóricas, podemos afirmar que los datos trabajados no corresponden a un CSR.</p>
<p>Para sustentar esta última afirmación, podemos utilizar la prueba quadrat, la cual también da evidencia en contra de la hipótesis de CSR.</p>
<div class="cell">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">quadrat.test</span>(X_nhpp, <span class="at">nx =</span> <span class="dv">4</span>, <span class="at">ny =</span> <span class="dv">4</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
    Chi-squared test of CSR using quadrat counts

data:  X_nhpp
X2 = 146.13, df = 15, p-value &lt; 2.2e-16
alternative hypothesis: two.sided

Quadrats: 4 by 4 grid of tiles</code></pre>
</div>
</div>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-KarlinTaylor2" class="csl-entry" role="listitem">
Karlin, Samuel, y Howard Taylor. 1981. <em>A Second Course in Stochastic Processes</em>. First. Academic Press.
</div>
<div id="ref-Kingman" class="csl-entry" role="listitem">
Kingman, John. 2007. <em>Poisson Processes</em>. Second. Claredon Press.
</div>
<div id="ref-Klenke" class="csl-entry" role="listitem">
Klenke, Achim. 2020. <em>Probability Theory: A Comprehensive Course</em>. Third. Wiley.
</div>
<div id="ref-Moraga" class="csl-entry" role="listitem">
Moraga, Paula. 2023. <em>Spatial Statistics for Data Science: Theory and Practice with R</em>. First. Chapman &amp; Hall/CRC.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copiado");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copiado");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../Caps/02-Exploratorio.html" class="pagination-link" aria-label="Análisis Exploratorio">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Análisis Exploratorio</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../references.html" class="pagination-link" aria-label="References">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>